%!PS-Adobe-2.0 EPSF-2.0
%%Title: makelogo 9.34
%%Creator: Tom Schneider, toms@ncifcrf.gov
%%BoundingBox:    57   710   876  891
%%Pages: atend
%%DocumentFonts:
%%EndComments
/llx  56.7 def
/lly 510.2 def
/urx 876.5 def
/ury 1190.6 def
% * position, samples, information, variance 
%
% logo from 0 to 71

/cmfactor 72 2.54 div def % defines points -> cm conversion
/cm {cmfactor mul} bind def % defines centimeters

% user defined parameters
/lowest 0 def
/highest 71 def
/bar 0 def
/xcorner  4.00000 cm def
/ycorner 26.00000 cm def
/rotation  0.00000 def % degrees
/charwidth  0.36000 cm def
/charwidth2m charwidth 2 mul def
/barheight  5.00000 cm def
/barwidth  0.10000 cm def
/barbits  3.46000 def % bits
/Ibeamfraction  1.00000 def
/barends (b) def
/subticsBig 2 def % sub-tic interval size (1/bits)
/subticsSmall 10 def % sub-tic interval size (1/bits)
/showingbox (n) def
/outline false def
/caps true def
/stacksperline 72 def
/linesperpage 1 def
/linemove  3.00000 def
/numbering true def
/shrinking false def
/edgecontrol (n) def
/edgeleft  2.00000 def
/edgeright  1.00000 def
/edgelow  8.00000 def
/edgehigh  1.00000 def
/shrink  1.00000 def
/ShowEnds (-) def % d: DNA, p: PROTEIN, -: none
/HalfWhiteIbeam false def

/knirhs 1 shrink sub 2 div def
/charwidth4 charwidth 4 div def
/charwidth2 charwidth 2 div def

/outlinewidth {charwidth 32 div} def
/setthelinewidth {% set the linewidth
  outline
    {outlinewidth setlinewidth}
    {1 setlinewidth}
  ifelse
} def
/toggleoutline { % switch the state of outlineing
pop pop pop pop
/outline outline not def
setthelinewidth
} def

% define fonts
/ffss {findfont fontsize scalefont setfont} def
/FontForStringRegular {/Times-Bold       ffss} def
/FontForStringItalic  {/Times-BoldItalic ffss} def
/FontForLogo          {/Helvetica-Bold   ffss} def
/FontForPrime         {/Symbol           ffss} def
/FontForSymbol        {/Symbol           ffss} def

% Set up the font size for the graphics
/fontsize charwidth def

% movements to place 5' and 3' symbols
/fivemovex {0} def
/fivemovey {(0) charparams lx ux sub 3 mul} def
/threemovex {(0) stringwidth pop 0.5 mul} def
/threemovey {fivemovey} def
/prime {FontForPrime (\242) show FontForStringRegular} def

% make italics possible in titles
/IT {% TRstring ITstring IT -
  exch show
  FontForStringItalic
  show
  FontForStringRegular
} def


% make symbols possible in titles
/SY {% TRstring SYstring SY -
  exch show
  FontForSymbol
  show
  FontForStringRegular
} def

%(*[[ This special comment allows deletion of the repeated
% procedures when several logos are concatenated together
% See the censor program.

/charparams { % char charparams => uy ux ly lx
% takes a single character and returns the coordinates that
% defines the outer bounds of where the ink goes
  gsave
    newpath
    0 0 moveto
    % take the character off the stack and use it here:
    true charpath 
    flattenpath 
    pathbbox % compute bounding box of 1 pt. char => lx ly ux uy
    % the path is here, but toss it away ...
  grestore
  /uy exch def
  /ux exch def
  /ly exch def
  /lx exch def
} bind def

/dashbox { % xsize ysize dashbox -
% draw a dashed box of xsize by ysize (in points)
  /ysize exch def % the y size of the box
  /xsize exch def % the x size of the box
  1 setlinewidth
  gsave
    % Define the width of the dashed lines for boxes:
    newpath
    0 0 moveto
    xsize 0 lineto
    xsize ysize lineto
    0 ysize lineto
    0 0 lineto
    [3] 0 setdash
    stroke
  grestore
  setthelinewidth
} bind def

/boxshow { % xsize ysize char boxshow
% show the character with a box around it, sizes in points
gsave
  /tc exch def % define the character
  /ysize exch def % the y size of the character
  /xsize exch def % the x size of the character
  /xmulfactor 1 def /ymulfactor 1 def

  % if ysize is negative, make everything upside down!
  ysize 0 lt {
    % put ysize normal in this orientation
    /ysize ysize abs def
    xsize ysize translate
    180 rotate
  } if

  shrinking {
    xsize knirhs mul ysize knirhs mul translate
    shrink shrink scale
  } if

  2 {
    gsave
    xmulfactor ymulfactor scale
    tc charparams
    grestore

    ysize % desired size of character in points
    uy ly sub % height of character in points
    dup 0.0 ne {
      div % factor by which to scale up the character
      /ymulfactor exch def
    } % end if
    {pop pop}
    ifelse

    xsize % desired size of character in points
    ux lx sub % width of character in points
    dup 0.0 ne {
      div % factor by which to scale up the character
      /xmulfactor exch def
    } % end if
    {pop pop}
    ifelse
  } repeat

  % Adjust horizontal position if the symbol is an I
  tc (I) eq {charwidth 2 div % half of requested character width
             ux lx sub 1 div % half of the actual character
                sub      0 translate} if
  % Avoid x scaling for I
  tc (I) eq {/xmulfactor 2 def} if

  /xmove xmulfactor lx mul neg def
  /ymove ymulfactor ly mul neg def

  newpath
  xmove ymove moveto
  xmulfactor ymulfactor scale

  outline {  % outline characters:
setthelinewidth
    tc true charpath
    gsave 1 setgray fill grestore
    clip stroke
}
  { % regular characters
    tc show
  }
  ifelse
grestore
} def

/numchar{ % charheight character numchar
% Make a character of given height in cm,
% then move vertically by that amount
  gsave
    /char exch def
    /charheight exch cm def
    /visible true def % most characters are visible
    char (K) eq {0 0 1 setrgbcolor} if
    char (R) eq {0 0 1 setrgbcolor} if
    char (H) eq {0 0 1 setrgbcolor} if
    char (k) eq {0 0 1 setrgbcolor} if
    char (r) eq {0 0 1 setrgbcolor} if
    char (h) eq {0 0 1 setrgbcolor} if
    char (D) eq {1 0 0 setrgbcolor} if
    char (E) eq {1 0 0 setrgbcolor} if
    char (d) eq {1 0 0 setrgbcolor} if
    char (e) eq {1 0 0 setrgbcolor} if
    char (N) eq {  0.6000 0   0.8500 setrgbcolor} if
    char (Q) eq {  0.6000 0   0.8500 setrgbcolor} if
    char (n) eq {  0.6000 0   0.8500 setrgbcolor} if
    char (q) eq {  0.6000 0   0.8500 setrgbcolor} if
    char (F) eq {1 0 1 setrgbcolor} if
    char (Y) eq {1 0 1 setrgbcolor} if
    char (W) eq {1 0 1 setrgbcolor} if
    char (f) eq {1 0 1 setrgbcolor} if
    char (y) eq {1 0 1 setrgbcolor} if
    char (w) eq {1 0 1 setrgbcolor} if
    char (G) eq {0   0.7000 0 setrgbcolor} if
    char (A) eq {0   0.7000 0 setrgbcolor} if
    char (S) eq {0   0.7000 0 setrgbcolor} if
    char (T) eq {0   0.7000 0 setrgbcolor} if
    char (g) eq {0   0.7000 0 setrgbcolor} if
    char (a) eq {0   0.7000 0 setrgbcolor} if
    char (s) eq {0   0.7000 0 setrgbcolor} if
    char (t) eq {0   0.7000 0 setrgbcolor} if
    char (C) eq {1   0.8500 0 setrgbcolor} if
    char (c) eq {1   0.8500 0 setrgbcolor} if
    char (P) eq {0 1 1 setrgbcolor} if
    char (p) eq {0 1 1 setrgbcolor} if
    char (X) eq {0 0 0 setrgbcolor} if
    char (M) eq {0 0 0 setrgbcolor} if
    char (I) eq {0 0 0 setrgbcolor} if
    char (L) eq {0 0 0 setrgbcolor} if
    char (V) eq {0 0 0 setrgbcolor} if
    char (x) eq {0 0 0 setrgbcolor} if
    char (m) eq {0 0 0 setrgbcolor} if
    char (i) eq {0 0 0 setrgbcolor} if
    char (l) eq {0 0 0 setrgbcolor} if
    char (v) eq {0 0 0 setrgbcolor} if
    char (*) eq {1 0 0 setrgbcolor} if
    char (\\) eq {0 1 0 setrgbcolor} if
    char (\%) eq {0 0 1 setrgbcolor} if
    char (+) eq {1 0 1 setrgbcolor} if
     visible {
       % implement boxes, fill and characters:
       showingbox (s) eq
       showingbox (f) eq
       or
       {gsave
           ly lx
           ly charwidth add
           lx charheight add
           boxsymbol
           clip
           showingbox (f) eq
           {fill}  
           {gsave 0 setgray stroke grestore  
            charwidth charheight char boxshow
           }
           ifelse
       grestore
       }
       {charwidth charheight char boxshow}
       ifelse
     } if % visibility control
  grestore
  charheight abs 1 gt {0 charheight abs translate} if
} bind def

/Ibar{
% make a horizontal bar
gsave
  newpath
    charwidth4 neg 0 moveto
    charwidth4 0 lineto
  stroke
grestore
} bind def

/Ibeam{ % height Ibeam
% Make an Ibeam of twice the given height, in cm
  /height exch cm def
  /heightDRAW height Ibeamfraction mul def
  1 setlinewidth
     HalfWhiteIbeam outline not and
     {0.75 setgray} % grey on bottom
     {0 setgray} % black on bottom
  ifelse
  gsave
    charwidth2 height neg translate
    Ibar
    newpath
      0 0 moveto
      0 heightDRAW rlineto
    stroke
    0 setgray % black on top
    newpath
      0 height moveto
      0 height rmoveto
      currentpoint translate
    Ibar
    newpath
      0 0 moveto
      0 heightDRAW neg rlineto
      currentpoint translate
    stroke
  grestore
  setthelinewidth
} bind def

/makenumber { % number makenumber
% make the number
gsave
  shift % shift to the other side of the stack
  90 rotate % rotate so the number fits
  dup stringwidth pop % find the length of the number
  neg % prepare for move
  charwidth (0) charparams uy ly sub % height of numbers
  sub 2 div %
  moveto % move back to provide space
  show
grestore
} bind def

/shift{ % move to the next horizontal position
charwidth 0 translate
} bind def

/bar2 barwidth 2 div def
/bar2n bar2 neg def
/makebar { % make a vertical bar at the current location
gsave
   bar2n 0 moveto
   barwidth 0 rlineto
   0 barheight rlineto
   barwidth neg 0 rlineto
   closepath
   fill
grestore
} def

% definitions for maketic
/str 10 string def % string to hold number
% points of movement between tic marks:
% (abs protects against barbits being negative)
/ticmovement barheight barbits abs div def

/maketic { % make tic marks and numbers
% define tic mark to be the width of the number 4:
(4) stringwidth pop
/ticwidth exch def % width of tic (as a dash) to show
gsave
  % initial increment limit proc for
  0 1 barbits abs cvi
  {/loopnumber exch def

    % convert the number coming from the loop to a string
    % and find its width
    loopnumber 10 str cvrs
    /stringnumber exch def % string representing the number

    stringnumber stringwidth pop
    /numberwidth exch def % width of number to show

    /halfnumberheight
      stringnumber charparams % capture sizes
      uy ly sub 2 div
    def


    numberwidth % move back width of number
    neg loopnumber ticmovement mul % shift on y axis
    halfnumberheight sub % down half the digit

    moveto % move back the width of the string

    ticwidth neg 0 rmoveto % move back the width of the tic

    stringnumber show

    % now show the tic mark
    0 halfnumberheight rmoveto % shift up again
    ticwidth 0 rlineto
    stroke
  } for
grestore

% do additional BIG tic marks.  subtics is user defined
  % initial increment limit proc for
gsave
  0 1 barbits subticsBig mul abs cvi
  {/bitnumber exch subticsBig div subticsBig div def
    0
    neg bitnumber ticmovement mul subticsBig mul % shift on y axis
    moveto
    ticwidth neg 0 rlineto
    stroke
  } for
/subticsBig 2 def % sub-tic interval size (1/bits)
% do additional SMALL tic marks.  subticsSmall is user defined
/ticwidth ticwidth 2 div def % halve the ticwidth
  % initial increment limit proc for
gsave
  0 1 barbits subticsSmall mul abs cvi
  {/bitnumber exch subticsSmall div subticsSmall div def
    0
    neg bitnumber ticmovement mul subticsSmall mul % shift on y axis
    moveto
    ticwidth neg 0 rlineto
    stroke
  } for
grestore
gsave
  /labelstring (bits) def
  numberwidth neg 2.5 mul
  barheight
  labelstring stringwidth pop
  sub 2 div
  translate
  90 rotate
  0 0 moveto
  labelstring show
grestore
} def

/degpercycle 360 def
 
/drawcosine {% amplitude  phase  wavelength  base
%              xmin ymin xmax ymax step
%              dashon dashoff dashoffset thickness
%              cosine -
% draws a cosine wave with the given parameters:
% amplitude (points): height of the wave
% phase (points): starting point of the wave
% wavelength (points): length from crest to crest
% base (points): lowest point of the curve
% xmin ymin xmax ymax (points): region in which to draw
% step steps for drawing a cosine wave
% dashon if greater than zero, size of dashes of the wave (points)
% dashon dashing on interval (points)
% dashoff dashing off interval (points)
% dashoffset offset for dashing (points)
% thickness if greater than zero, thickness of wave (points)
% use dashon and dashoff as blank and dashoffset as 0 for solid line
% See PostScrirt Language Reference Manual 2nd ed p. 500 on dash.

  /thickness exch def
  /dashoffset exch def
  /dashoff exch def
  /dashon exch def
  /step exch def
  /ymax exch def
  /xmax exch def
  /ymin exch def
  /xmin exch def
  /base exch def
  /wavelength exch def
  /phase exch def
  /amplitude exch def
  % fun := amplitude*cos( ((-y-phase)/wavelength)*360) + base
  /fun {phase sub wavelength div degpercycle mul cos
           amplitude mul base add} def

  gsave
    /originallinewidth currentlinewidth def
    thickness 0 gt {thickness setlinewidth} if

    % Force the curve to fit into the region specified:
    newpath
    xmin ymin moveto
    xmax ymin lineto
    xmax ymax lineto
    xmin ymax lineto
    closepath
    clip

    newpath
    xmin dup fun moveto
    % go to xmin-1 and xmax+1 to make sure we overlap the
    % next wave if there is one.  The clip above ensures that it
    % goes no further than requested. 
    % loop from xmin-1 to xmax+1 by step:
    xmin 1 sub step xmax 1 add {dup fun lineto} for
    % turn dash on if dashon is positive
    dashon 0 gt {[dashon cvi dashoff cvi] dashoffset setdash} if
    stroke

    originallinewidth setlinewidth
  grestore
} bind def

/circlesymbol { % x y radius circlesymbol - (path)
newpath 0 360 arc closepath} bind def

/sqrt3 3 sqrt def
/trianglesymbol { % x y radius trianglesymbol - (path)
/r exch def
/sqrt3r sqrt3 r mul def
translate
120 rotate
0 r translate
-120 rotate
newpath
0 0 moveto
sqrt3r 0 lineto
-300 rotate
sqrt3r 0 lineto
closepath} bind def

/squaresymbol { % x y side squaresymbol - (path)
/side exch def
translate
side 2 div neg dup translate
newpath
0 0 moveto
0 side lineto
side side lineto
side 0 lineto
closepath} bind def

/linesymbol { % x1 y1 x2 y2 linesymbol - (path)
/y2 exch def
/x2 exch def
/y1 exch def
/x1 exch def
newpath
x1 y1 moveto
x2 y2 lineto
} bind def

/boxsymbol { % x1 y1 x2 y2 boxsymbol - (path)
/y2 exch def
/x2 exch def
/y1 exch def
/x1 exch def
newpath
x1 y1 moveto
x2 y1 lineto
x2 y2 lineto
x1 y2 lineto
closepath
} bind def

% The following special comment allows deletion of the repeated
% procedures when several logos are concatenated together
% See the censor program.
%]]%*)

/startpage { % start a page
  save % [ startpage
  % set the font used in the title strings
  FontForStringRegular
  gsave % [ startpage
  xcorner ycorner translate
  rotation rotate
  % create the user defined strings
  gsave
    /stringscale  2.00000 def
     0.00000 cm -1.00000 cm moveto
    stringscale stringscale scale
    ()
    show
  grestore
  gsave
    % string number 1
    % center the string
    /stringscale  2.00000 def
    ()
    stringwidth pop
    stringscale mul neg
    stacksperline charwidth mul
    add 2 div
    -1.00000 cm moveto
    stringscale stringscale scale
    ()
    show
  grestore
  % now move up to the top of the top line:
  0 linesperpage linemove barheight mul mul translate

  % set the font used in the logos
  FontForLogo
} def

%(*[[ This special comment allows deletion of the repeated
% procedures when several logos are concatenated together
% See the censor program.

/endpage { % end a page
  grestore % ] endpage
  showpage % REMOVE FOR PACKAGING INTO ANOTHER FIGURE
  restore % ] endpage
} def

/showleftend {
gsave
 charwidth neg 0 translate
 fivemovex fivemovey moveto ShowEnds (d) eq {(5) show prime} if
 ShowEnds (p) eq {(N) show} if
grestore
} def

/showrightend {
gsave
 threemovex threemovey moveto ShowEnds (d) eq {(3) show prime} if
 ShowEnds (p) eq {(C) show} if
grestore
} def

/startline{ % start a line
% move down to the bottom of the line:
  0 linemove barheight mul neg translate
  gsave % [ startline
  % put a bar on the left side:
  barends (b) eq barends (l) eq or {
    maketic % maketic.startline
    gsave
      bar2n 0 translate % makebar.startline
      makebar % makebar.startline
    grestore
  } if
  showleftend
} def

/endline{ % end a line
  showrightend
  % put a bar on the right side:
  barends (b) eq barends (r) eq or {
    gsave
      bar2 0 translate % makebar.endline
      makebar % makebar.endline
    grestore
  } if
  grestore % ] startline
} def

% @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
% @@@@@@@@@@@@@@@@@@@@ End of procedures @@@@@@@@@@@@@@@@@@@
% @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

% The following special comment allows deletion of the repeated
% procedures when several logos are concatenated together
% See the censor program.
%]]%*)

%%EndProlog

%%Page: 1 1
startpage % [
startline % line number 1
% before coordinate 0: make the bar
makebar
% at coordinate 0
numbering {(0) makenumber} if
gsave
 0.14498 (Y) numchar
 0.20946 (D) numchar
 0.21054 (E) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 1
numbering {(1) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 2
numbering {(2) makenumber} if
gsave
 0.00190 (I) numchar
 0.00471 (F) numchar
 0.00594 (L) numchar
 0.00691 (Q) numchar
 0.00848 (Y) numchar
 0.02375 (S) numchar
 0.19993 (V) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 3
numbering {(3) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 4
numbering {(4) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 5
numbering {(5) makenumber} if
gsave
 0.00281 (E) numchar
 0.00660 (R) numchar
 0.01206 (A) numchar
 0.02782 (L) numchar
 0.03782 (V) numchar
 0.09294 (C) numchar
 0.17327 (T) numchar
 0.28879 (N) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 6
numbering {(6) makenumber} if
gsave
 0.00396 (L) numchar
 0.00554 (P) numchar
 0.02741 (M) numchar
 0.03246 (A) numchar
 0.03486 (I) numchar
 0.04455 (D) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 7
numbering {(7) makenumber} if
gsave
 0.00073 (R) numchar
 0.00073 (S) numchar
 0.00073 (Q) numchar
 0.00073 (N) numchar
 0.00073 (P) numchar
 0.00073 (X) numchar
 0.00073 (Y) numchar
 0.00073 (W) numchar
 0.00073 (T) numchar
 0.00073 (V) numchar
 0.00073 (M) numchar
 0.00073 (E) numchar
 0.00073 (F) numchar
 0.00073 (D) numchar
 0.00073 (A) numchar
 0.00073 (C) numchar
 0.00073 (K) numchar
 0.00073 (L) numchar
 0.00073 (I) numchar
 0.00073 (G) numchar
 0.00073 (H) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 8
numbering {(8) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 9
numbering {(9) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 10
numbering {(10) makenumber} if
gsave
 0.00098 (L) numchar
 0.00229 (I) numchar
 0.00280 (C) numchar
 0.01304 (Y) numchar
 0.01476 (M) numchar
 0.01804 (H) numchar
 0.01871 (V) numchar
 0.01884 (D) numchar
 0.01884 (Q) numchar
 0.01894 (E) numchar
 0.01927 (G) numchar
 0.01937 (P) numchar
 0.01948 (N) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 11
numbering {(11) makenumber} if
gsave
 0.01604 (V) numchar
 0.01633 (C) numchar
 0.01701 (F) numchar
 0.01837 (Y) numchar
 0.01893 (A) numchar
 0.01944 (K) numchar
 0.02076 (I) numchar
 0.02360 (L) numchar
 0.03391 (T) numchar
 0.23543 (G) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 12
numbering {(12) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 13
numbering {(13) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 14
numbering {(14) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 15
numbering {(15) makenumber} if
gsave
 0.00077 (P) numchar
 0.00221 (W) numchar
 0.00426 (C) numchar
 0.00441 (Y) numchar
 0.00579 (L) numchar
 0.00702 (M) numchar
 0.00772 (T) numchar
 0.01287 (A) numchar
 0.01545 (S) numchar
 0.01545 (R) numchar
 0.01545 (D) numchar
 0.01545 (I) numchar
 0.01545 (K) numchar
 0.01545 (H) numchar
 0.01545 (N) numchar
 0.01545 (F) numchar
 0.01622 (E) numchar
 0.01957 (G) numchar
 0.02630 (V) numchar
 0.05020 (Q) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 16
numbering {(16) makenumber} if
gsave
 0.00157 (C) numchar
 0.00507 (K) numchar
 0.00548 (N) numchar
 0.00801 (A) numchar
 0.00951 (F) numchar
 0.01027 (Y) numchar
 0.02065 (I) numchar
 0.02491 (M) numchar
 0.16441 (T) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 17
numbering {(17) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 18
numbering {(18) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 19
numbering {(19) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 20
numbering {(20) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 21
numbering {(21) makenumber} if
gsave
 0.13764 (G) numchar
 0.48425 (P) numchar
 0.71758 (V) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 22
numbering {(22) makenumber} if
gsave
 0.00511 (D) numchar
 0.04402 (H) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 23
numbering {(23) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 24
numbering {(24) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 25
numbering {(25) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 26
numbering {(26) makenumber} if
gsave
 0.00348 (L) numchar
 0.00867 (T) numchar
 0.01346 (C) numchar
 0.01446 (W) numchar
 0.01502 (R) numchar
 0.01506 (F) numchar
 0.01518 (S) numchar
 0.01606 (M) numchar
 0.01668 (N) numchar
 0.01728 (V) numchar
 0.01838 (I) numchar
 0.36139 (K) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 27
numbering {(27) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 28
numbering {(28) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 29
numbering {(29) makenumber} if
gsave
 0.91957 (I) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 30
numbering {(30) makenumber} if
gsave
 0.29647 (M) numchar
 0.33351 (D) numchar
 0.38566 (L) numchar
 0.61572 (T) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 31
numbering {(31) makenumber} if
gsave
 0.00544 (V) numchar
 0.00792 (R) numchar
 0.00997 (N) numchar
 0.01512 (M) numchar
 0.01847 (H) numchar
 0.01888 (L) numchar
 0.01979 (A) numchar
 0.01984 (P) numchar
 0.02821 (G) numchar
 0.07274 (E) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 32
numbering {(32) makenumber} if
gsave
 0.00464 (F) numchar
 0.00497 (K) numchar
 0.00516 (R) numchar
 0.00516 (P) numchar
 0.00516 (Q) numchar
 0.00516 (S) numchar
 0.00516 (W) numchar
 0.00516 (Y) numchar
 0.00516 (T) numchar
 0.00516 (V) numchar
 0.00516 (N) numchar
 0.00516 (D) numchar
 0.00516 (E) numchar
 0.00516 (A) numchar
 0.00516 (C) numchar
 0.00516 (G) numchar
 0.00516 (L) numchar
 0.00516 (M) numchar
 0.00516 (H) numchar
 0.00516 (I) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 33
numbering {(33) makenumber} if
gsave
 0.00989 (I) numchar
 0.01175 (S) numchar
 0.01287 (L) numchar
 0.01374 (V) numchar
 0.01436 (Q) numchar
 0.01473 (A) numchar
 0.02136 (G) numchar
 0.02449 (E) numchar
 0.02519 (T) numchar
 0.02571 (P) numchar
 0.02665 (R) numchar
 0.03110 (K) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 34
numbering {(34) makenumber} if
gsave
 0.03258 (H) numchar
 0.03298 (Y) numchar
 0.03383 (N) numchar
 0.03403 (Q) numchar
 0.03403 (D) numchar
 0.03421 (E) numchar
 0.03490 (K) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 35
numbering {(35) makenumber} if
gsave
 0.01756 (S) numchar
 0.02090 (X) numchar
 0.02090 (M) numchar
 0.02171 (N) numchar
 0.02184 (I) numchar
 0.02239 (K) numchar
 0.02257 (T) numchar
 0.03285 (R) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 36
numbering {(36) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 37
numbering {(37) makenumber} if
gsave
 0.01123 (L) numchar
 0.01729 (V) numchar
 0.01931 (A) numchar
 0.02101 (P) numchar
 0.04481 (G) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 38
numbering {(38) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 39
numbering {(39) makenumber} if
gsave
 0.10077 (Y) numchar
 0.16461 (P) numchar
 0.52683 (N) numchar
 0.89597 (R) numchar
 1.07283 (A) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 40
numbering {(40) makenumber} if
gsave
 0.01694 (R) numchar
 0.02012 (G) numchar
 0.02236 (L) numchar
 0.06179 (F) numchar
 0.26365 (K) numchar
 0.59323 (M) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 41
numbering {(41) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 42
numbering {(42) makenumber} if
gsave
 0.14994 (G) numchar
 0.34374 (S) numchar
 1.10489 (Y) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 43
numbering {(43) makenumber} if
gsave
 0.01911 (Q) numchar
 0.18960 (G) numchar
 0.25507 (L) numchar
 0.26672 (S) numchar
 0.48901 (E) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 44
numbering {(44) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 45
numbering {(45) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 46
numbering {(46) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 47
numbering {(47) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 48
numbering {(48) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 49
numbering {(49) makenumber} if
gsave
 0.03509 (V) numchar
 0.03722 (F) numchar
 0.03958 (N) numchar
 0.03970 (X) numchar
 0.04019 (Y) numchar
 0.08624 (C) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 50
numbering {(50) makenumber} if
gsave
 3.17822 (W) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 51
numbering {(51) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 52
numbering {(52) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 53
numbering {(53) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 54
numbering {(54) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 55
numbering {(55) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 56
numbering {(56) makenumber} if
gsave
 2.13091 (K) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 57
numbering {(57) makenumber} if
gsave
 0.00595 (M) numchar
 0.00706 (T) numchar
 0.01285 (V) numchar
 0.03533 (N) numchar
 0.04732 (Y) numchar
 0.05152 (E) numchar
 0.05520 (F) numchar
 0.06835 (D) numchar
 0.07976 (A) numchar
 0.08741 (G) numchar
 0.62406 (I) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 58
numbering {(58) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 59
numbering {(59) makenumber} if
gsave
 0.19643 (K) numchar
 0.60746 (R) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 60
numbering {(60) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 61
numbering {(61) makenumber} if
gsave
 0.01256 (Q) numchar
 0.04497 (R) numchar
 0.04831 (A) numchar
 0.05959 (S) numchar
 0.18690 (G) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 62
numbering {(62) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 63
numbering {(63) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 64
numbering {(64) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 65
numbering {(65) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 66
numbering {(66) makenumber} if
gsave
 0.00163 (L) numchar
 0.00394 (E) numchar
 0.00874 (S) numchar
 0.02372 (A) numchar
 0.02866 (I) numchar
 0.08452 (F) numchar
 0.13523 (R) numchar
 0.20034 (K) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 67
numbering {(67) makenumber} if
gsave
 0.00409 (S) numchar
 0.00936 (V) numchar
 0.01479 (C) numchar
 0.07946 (K) numchar
 0.09534 (X) numchar
 0.27669 (L) numchar
 0.77236 (T) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 68
numbering {(68) makenumber} if
gsave
 0.13608 (V) numchar
 0.16495 (A) numchar
 0.21015 (S) numchar
 0.39961 (G) numchar
 0.00000 Ibeam
grestore
shift
% at coordinate 69
numbering {(69) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 70
numbering {(70) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
% at coordinate 71
numbering {(71) makenumber} if
gsave
 0.00000 Ibeam
grestore
shift
endline
endpage % ]
% Rs total is  4.47881 +/-  0.00000 bits in the range from 0 to 71
%%Trailer
%%Pages: 1
